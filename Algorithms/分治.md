## 分析分治算法

T(n) = O(1)  for n <= c

T(n) = aT(n/b) + D(n) + C(n) for others

c为某个常量，表示当问题的规模足够小的时候可以直接求解。 a是分成子问题的规模，子问题是原问题的1/b，D(n)是分解问题所需要的时间，C(n)是合并问题所需要的时间。

## 分治排序算法

时间复杂度分析：T(n) = 2T(n/2) + cn, 其递归树有logn + 1层（假设n是2的幂次），每层代价都是cn，故总代价为：cnlgn + cn。

ps：merge过程中使用哨兵（数组的最后一个位置设置成无限大）来表示数组已经为空。

## 三种求解递归式的方法
1. 代入法： a. guess the final answer b. use the induction method to prove it
2. 递归树法
3. 主方法，求解型如下的递归式的界：
	T(n) = aT(n/b) + f(n), 比较f(n)和n^(lg(b,a))的关系，分成三种情况：

Problem1: 已知一个数组，求这个最大的点对(x, y)使得a[y] - a[x]的值最大。

	Solutions: 1. 相邻项求差，之后套用最大子段和问题。 2. 当成区间问题求解，维护一个最大值，一个最小值，一个差。

Problem2: 已知有n个芯片，每对芯片（A，B）进行测试的时候会产生如下四种结果，如果芯片本来就是好的的话则测试结果可信，否则，测试结果不可信：

	1.（A好，B好）则AB都好或者都坏 
	2.（A好，B坏）至少一个是坏的 
	3.（A坏，B好）至少一个是坏的
	4.（A坏，B坏）至少一个是坏的 

	输入n，k代表芯片总数和好芯片的个数，输出最坏情况下测试出所有好芯片的最小测试次数，如果不能测试出则输出-1。

	Solutions: 1. k > n/2 2. 个人现在的直观感觉是左边1～k都是好的右边都是坏的，从坏的开始判这是最坏情况，每次判坏需要（nn-k）+1，共n-k轮。
